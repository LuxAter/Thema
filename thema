#!/bin/bash

# Created by argbash-init v2.8.1
# ARG_HELP([System wide theme configuration tool])
# ARG_VERSION_AUTO([2.0.0])
# ARG_OPTION_STACKING([getopts])
# ARG_OPTIONAL_REPEATED([output],[o],[outputs to install new theme],[])
# ARG_OPTIONAL_SINGLE([theme],[t],[theme to install])
# ARG_OPTIONAL_SINGLE([variant],[],[theme variant to install],[])
# ARG_OPTIONAL_BOOLEAN([list-themes],[],[list available themes],[off])
# ARG_OPTIONAL_BOOLEAN([list-variants],[],[list available variants],[off])
# ARG_OPTIONAL_BOOLEAN([list-outputs],[],[list available outputs],[off])
# ARG_OPTIONAL_BOOLEAN([quiet],[q],[quiet execution, no output to stdout],[off])
# ARG_OPTIONAL_BOOLEAN([fancy],[f],[fancy formatted output],[on])
# ARG_OPTIONAL_SINGLE([remote_url],[u],[remote url to use if necessary],[https://raw.githubusercontent.com/LuxAter/Thema/master/])
# ARG_OPTIONAL_BOOLEAN([remote],[r],[use remote configuration/files],[off])
# ARGBASH_SET_INDENT([  ])
# ARGBASH_GO()
# needed because of Argbash --> m4_ignore([
### START OF CODE GENERATED BY Argbash v2.8.1 one line above ###
# Argbash is a bash code generator used to get arguments parsing right.
# Argbash is FREE SOFTWARE, see https://argbash.io for more info


die()
{
  local _ret=$2
  test -n "$_ret" || _ret=1
  test "$_PRINT_HELP" = yes && print_help >&2
  echo "$1" >&2
  exit ${_ret}
}


# THE DEFAULTS INITIALIZATION - OPTIONALS
_arg_output=()
_arg_theme=
_arg_variant=
_arg_list_themes="off"
_arg_list_variants="off"
_arg_list_outputs="off"
_arg_quiet="off"
_arg_fancy="on"
_arg_remote_url="https://raw.githubusercontent.com/LuxAter/Thema/master/"
_arg_remote="off"


print_help()
{
  printf '%s\n' "System wide theme configuration tool"
  printf 'Usage: %s [-h|--help] [-v|--version] [-o|--output <arg>] [-t|--theme <arg>] [--variant <arg>] [--(no-)list-themes] [--(no-)list-variants] [--(no-)list-outputs] [-q|--(no-)quiet] [-f|--(no-)fancy] [-u|--remote_url <arg>] [-r|--(no-)remote]\n' "$0"
  printf '\t%s\n' "-h, --help: Prints help"
  printf '\t%s\n' "-v, --version: Prints version"
  printf '\t%s\n' "-o, --output: outputs to install new theme (empty by default)"
  printf '\t%s\n' "-t, --theme: theme to install (no default)"
  printf '\t%s\n' "--variant: theme variant to install (no default)"
  printf '\t%s\n' "--list-themes, --no-list-themes: list available themes (off by default)"
  printf '\t%s\n' "--list-variants, --no-list-variants: list available variants (off by default)"
  printf '\t%s\n' "--list-outputs, --no-list-outputs: list available outputs (off by default)"
  printf '\t%s\n' "-q, --quiet, --no-quiet: quiet execution, no output to stdout (off by default)"
  printf '\t%s\n' "-f, --fancy, --no-fancy: fancy formatted output (on by default)"
  printf '\t%s\n' "-u, --remote_url: remote url to use if necessary (default: 'https://raw.githubusercontent.com/LuxAter/Thema/master/')"
  printf '\t%s\n' "-r, --remote, --no-remote: use remote configuration/files (off by default)"
}


parse_commandline()
{
  while test $# -gt 0
  do
    _key="$1"
    case "$_key" in
      -h|--help)
        print_help
        exit 0
        ;;
      -v|--version)
        printf '%s %s\n\n%s\n' "thema" "2.0.0" 'System wide theme configuration tool'
        exit 0
        ;;
      -o|--output)
        test $# -lt 2 && die "Missing value for the optional argument '$_key'." 1
        _arg_output+=("$2")
        shift
        ;;
      --output=*)
        _arg_output+=("${_key##--output=}")
        ;;
      -t|--theme)
        test $# -lt 2 && die "Missing value for the optional argument '$_key'." 1
        _arg_theme="$2"
        shift
        ;;
      --theme=*)
        _arg_theme="${_key##--theme=}"
        ;;
      --variant)
        test $# -lt 2 && die "Missing value for the optional argument '$_key'." 1
        _arg_variant="$2"
        shift
        ;;
      --variant=*)
        _arg_variant="${_key##--variant=}"
        ;;
      --no-list-themes|--list-themes)
        _arg_list_themes="on"
        test "${1:0:5}" = "--no-" && _arg_list_themes="off"
        ;;
      --no-list-variants|--list-variants)
        _arg_list_variants="on"
        test "${1:0:5}" = "--no-" && _arg_list_variants="off"
        ;;
      --no-list-outputs|--list-outputs)
        _arg_list_outputs="on"
        test "${1:0:5}" = "--no-" && _arg_list_outputs="off"
        ;;
      -q|--no-quiet|--quiet)
        _arg_quiet="on"
        test "${1:0:5}" = "--no-" && _arg_quiet="off"
        ;;
      -f|--no-fancy|--fancy)
        _arg_fancy="on"
        test "${1:0:5}" = "--no-" && _arg_fancy="off"
        ;;
      -u|--remote_url)
        test $# -lt 2 && die "Missing value for the optional argument '$_key'." 1
        _arg_remote_url="$2"
        shift
        ;;
      --remote_url=*)
        _arg_remote_url="${_key##--remote_url=}"
        ;;
      -r|--no-remote|--remote)
        _arg_remote="on"
        test "${1:0:5}" = "--no-" && _arg_remote="off"
        ;;
      *)
        _PRINT_HELP=yes die "FATAL ERROR: Got an unexpected argument '$1'" 1
        ;;
    esac
    shift
  done
}

parse_commandline "$@"

# OTHER STUFF GENERATED BY Argbash

### END OF CODE GENERATED BY Argbash (sortof) ### ])
# [ <-- needed because of Argbash

# Messaging
declare -rx DEFAULT="tput sgr0"
declare -rx RED="tput setaf 1"
declare -rx GREEN="tput setaf 2"
declare -rx YELLOW="tput setaf 3"
declare -rx BLUE="tput setaf 4"
declare -rx MAGENTA="tput setaf 5"
declare -rx CYAN="tput setaf 6"
declare -rx BOLD="tput bold"
cmsg() {
  [ "$_arg_quiet" == "on" ] && return 0
  if [ "$_arg_fancy" == "on" ]; then
    if [ $1 -gt 0 ]; then
      prefix="$(printf '=%.0s' $(seq 0 $(($1-1))))>"
      $2
      echo -n "$prefix"
      $DEFAULT
      echo " ${@:3}"
    else
      $2
      echo "${@:3}"
      $DEFAULT
    fi
  else
    echo "${@:3}"
  fi
}
msg() {
  cmsg "$1" "$DEFAULT" "${@:2}"
}
msg_error() {
  cmsg "$1" "$RED" "${@:2}"
}
msg_warn() {
  cmsg "$1" "$YELLOW" "${@:2}"
}
msg_success() {
  cmsg "$1" "$GREEN" "${@:2}"
}
msg_notice() {
  cmsg "$1" "$BLUE" "${@:2}"
}
msg_info() {
  cmsg "$1" "$CYAN" "${@:2}"
}
msg_debug() {
  cmsg "$1" "$DEFAULT" "${@:2}"
}
msg_ok() {
  cmsg "$1" "$GREEN" "${@:2}"
}
msg_und() {
  cmsg "$1" "$YELLOW" "${@:2}"
}
msg_header() {
  [ "$_arg_fancy" == "on" ] && cmsg "$1" "$BOLD" "${@:2}"
}

script_dir="$( cd "$( dirname "${BASH_SOURCE[0]}" )" >/dev/null 2>&1 && pwd )"
[ -f "$script_dir/thema" ] && using_local=true || using_local=false

hash "thema" 2>/dev/null
is_installed=$?
installed_dir=$(command -v "thema")
[ $is_installed -eq 0 ] && [ "$script_dir" == "$installed_dir" ] && using_installed=true || using_installed=false

[ $using_local == true ] && current_version=$($script_dir/thema --version | head -n 1 | awk '{print $2}') || current_version='latest'
[ "$_arg_remote" == "on" ] && using_local=false

# Configuration file/directory detection
if [ $using_local == false ]; then
  msg_header 0 "Fetching configuration file..."
  wget -q "$_arg_remote_url/thema.yml" -O "$script_dir/.thema.yml.tmp" &>/dev/null
  config_path="$script_dir/.thema.yml.tmp"
  config_dir="remote"
else
  echo "Checking for update..."
  # TODO!

  if [ -f "$script_dir/thema.yml" ]; then
    config_dir="$script_dir"
    config_path="$script_dir/thema.yml"
  elif [ -f "$script_dir/.thema.yml" ]; then
    config_dir="remote"
    config_path="$script_dir/.thema.yml"
  elif [ -f "$XDG_CONFIG_HOME/thema/theme.yml" ]; then
    config_dir="$XDG_CONFIG_HOME/thema"
    config_path="$XDG_CONFIG_HOME/thema/thema.yml"
  elif [ -f "$XDG_CONFIG_HOME/thema.yml" ]; then
    config_dir="remote"
    config_path="$XDG_CONFIG_HOME/thema.yml"
  elif [ -f "$HOME/.config/thema/thema.yml" ]; then
    config_dir="$HOME/.config/thema"
    config_path="$HOME/.config/thema/thema.yml"
  elif [ -f "$HOME/.thema.yml" ]; then
    config_dir="remote"
    config_path="$HOME/.thema.yml"
  fi
fi

if [ -z "$config_path" ] || ! [ -f "$config_path" ]; then
  msg_error 0 "Failed to locate configuration file, please specify a location, or remote"
  exit 1
fi

# YAML parsing functions

parse_yaml() {
    local yaml_file=$1
    local prefix=$2
    local s
    local w
    local fs

    s='[[:space:]]*'
    w='[a-zA-Z0-9_.-]*'
    fs="$(echo @|tr @ '\034')"

    (
        sed -e '/- [^\â€œ]'"[^\']"'.*: /s|\([ ]*\)- \([[:space:]]*\)|\1-\'$'\n''  \1\2|g' |

        sed -ne '/^--/s|--||g; s|\"|\\\"|g; s/[[:space:]]*$//g;' \
            -e "/#.*[\"\']/!s| #.*||g; /^#/s|#.*||g;" \
            -e "s|^\($s\)\($w\)$s:$s\"\(.*\)\"$s\$|\1$fs\2$fs\3|p" \
            -e "s|^\($s\)\($w\)${s}[:-]$s\(.*\)$s\$|\1$fs\2$fs\3|p" |

        awk -F"$fs" '{
            indent = length($1)/2;
            if (length($2) == 0) { conj[indent]="+";} else {conj[indent]="";}
            vname[indent] = $2;
            for (i in vname) {if (i > indent) {delete vname[i]}}
                if (length($3) > 0) {
                    vn=""; for (i=0; i<indent; i++) {vn=(vn)(vname[i])("_")}
                    printf("%s%s%s%s=(\"%s\")\n", "'"$prefix"'",vn, $2, conj[indent-1],$3);
                }
            }' |

        sed -e 's/_=/+=/g' |

        awk 'BEGIN {
                FS="=";
                OFS="="
            }
            /(-|\.).*=/ {
                gsub("-|\\.", "_", $1)
            }
            { print }'
    ) < "$yaml_file"
}

create_variables() {
    local yaml_file="$1"
    local prefix="$2"
    eval "$(parse_yaml "$yaml_file" "$prefix")"
}
array_len() {
  eval "echo \"\${#$1[*]}\""
}
get_array() {
  eval "echo \"\${$1[*]}\""
}
get_val() {
  eval "echo \"\$$1\""
}
has_val() {
  eval "[ -z \"\$$1\" ] && return 1 || return 0"
}

# Array utility functions
array_init() {
  read -a arr <<< "$@"
  echo ${arr[*]}
}
array_print() {
  printf -v joined "%s$1" "${@:2}"
  echo "${joined%$1}"
}
array_in() {
  [[ " ${@:2} " =~ " ${1} " ]] && echo "true" || echo "false"
}
array_unique() {
  output=""
  for x in $@; do
    if [ $(array_in "$x" $output) == false ]; then
      output="$output $x"
      echo $x
    fi
  done
}

# Load Configuration file
create_variables "$config_path" '_cfg_'
# declare -p
# echo ""


# Output Destination determination
find_dest() {
  for dest in $@; do
    [ -f "$dest" ] && echo "$dest" && return 0
  done
  return 1
}

# Output detection
output_get_targets() {
  declare -p | grep "_cfg_${1}_" | awk '{print $3}' | sed -n "s/\([^=]*\)_destination=.*/\1/p"
}
output_exists() {
  first_target=$(declare -p | grep "_cfg_${output}_" | awk '{print $3}' | sed -n "s/\([^=]*\)_destination=.*/\1/p" | head -n 1)
  destinations=($(get_array "${first_target}_destination"))
  dest=$(find_dest ${destinations[*]})
  if [ -z "$dest" ]; then
    return 1
  else
    return 0
  fi
}
output_uses_thema() {
  first_target=$(declare -p | grep "_cfg_${1}_" | awk '{print $3}' | sed -n "s/\([^=]*\)_destination=.*/\1/p" | head -n 1)
  destinations=($(get_array "${first_target}_destination"))
  dest=$(find_dest ${destinations[*]})
  if [ -z "$dest" ]; then
    return 1
  else
    if has_val "${first_target}_comment"; then
      comments=$(get_val "${first_target}_comment")
      comment_start=$(echo "$comments" | awk '{print $1}')
      comment_end=$(echo "$comments" | awk '{print $2}')
    else
      comment_start='#'
      comment_end=
    fi
    ecomment_start=$(sed 's/\//\\\//g' <<< "$comment_start")
    ecomment_start=$(sed 's/\*/\\\*/g' <<< "$comment_start")
    ecomment_end=$(sed 's/\//\\\//g' <<< "$comment_end")
    ecomment_end=$(sed 's/\*/\\\*/g' <<< "$comment_end")
    if grep -xq "$ecomment_start Thema Begin -- .* $ecomment_end" "$dest"; then
      return 0
    else
      return 1
    fi
  fi
}
outputs=($(declare -p | grep "_cfg_" | awk '{print $3}' | sed -n "s/_cfg_\([^_=]*\).*_destination=.*/\1/p"))
outputs=($(array_unique ${outputs[*]}))

if [ "${#_arg_output[*]}" -gt 0 ]; then
  output_str="${outputs[@]}"
  outputs=()
  for output in ${_arg_output[*]}; do
    [ $(array_in "$output" "$output_str") == true ] && outputs+=("$output")
  done
fi

active_themes=()
active_variants=()
active_theme_variants=()
for output in ${outputs[*]}; do
  first_target=$(declare -p | grep "_cfg_${output}_" | awk '{print $3}' | sed -n "s/\([^=]*\)_destination=.*/\1/p" | head -n 1)
  destinations=($(get_array "${first_target}_destination"))
  dest=$(find_dest ${destinations[*]})
  if ! [ -z "$dest" ]; then
    if has_val "${first_target}_comment"; then
      comments=$(get_val "${first_target}_comment")
      comment_start=$(echo "$comments" | awk '{print $1}')
      comment_end=$(echo "$comments" | awk '{print $2}')
    else
      comment_start='#'
      comment_end=
    fi
    ecomment_start=$(sed 's/\//\\\//g' <<< "$comment_start")
    ecomment_start=$(sed 's/\*/\\\*/g' <<< "$comment_start")
    ecomment_end=$(sed 's/\//\\\//g' <<< "$comment_end")
    ecomment_end=$(sed 's/\*/\\\*/g' <<< "$comment_end")
    if grep -xq "$ecomment_start Thema Begin -- .* $ecomment_end" "$dest"; then
      theme_variant=$(grep -x "$ecomment_start Thema Begin -- .* $ecomment_end" "$dest" | sed "s/$ecomment_start Thema Begin -- \(.*\) $ecomment_end/\1/")
      variant=${theme_variant#*(}
      variant=${variant%)*}
      active_themes+=("${theme_variant%(*}")
      active_variants+=("$variant")
      active_theme_variants+=("$theme_variant")
    fi
  fi
done

# List command
list_variants() {
  variants=_cfg_themes_$2
  if ! [ $(array_in 'default' $(array_init ${!variants})) == true ]; then
    for variant in $(array_init ${!variants}); do
      if [ "$_arg_fancy" == "on" ]; then
        msg_info $1 "$variant"
      else
        msg_info $1 "$2($variant)"
      fi
    done
  fi
}
list_themes() {
  msg_header 0 "Themes:"
  themes=$(declare -p | grep "_cfg_themes_" | awk '{print $3}' | sed -n "s/_cfg_themes_\([^=]*\).*/\1/p")
  for theme in ${themes[*]}; do
    if [ "$_arg_fancy" == "on" ]; then
      msg_notice 1 "$theme"
      if [ "$_arg_list_variants" == "on" ]; then
        list_variants 2 "$theme"
      fi
    else
      msg_notice 1 "$theme"
      if [ "$_arg_list_variants" == "on" ]; then
        list_variants 2 "$theme"
      fi
    fi
  done
}
list_outputs() {
  msg_header 0 "Outputs:"
  for output in ${outputs[*]}; do
    if output_uses_thema "$output"; then
      msg_success 1 "$output"
    elif output_exists "$output"; then
      msg_warn 1 "$output"
    else
      msg_error 1 "$output"
    fi
  done
}
_listing=false
if [ "$_arg_list_themes" == "on" ]; then
  list_themes
  _listing=true
elif [ "$_arg_list_variants" == "on" ]; then
  if [ -z "$_arg_theme" ]; then
    for theme in ${active_themes[*]}; do
      msg_notice 1 "$theme"
      list_variants 2 "$theme"
    done
  else
    msg_header 0 "$_arg_theme Variants:"
    list_variants 1 "$_arg_theme"
  fi
  _listing=true
fi
if [ "$_arg_list_outputs" == "on" ]; then
  list_outputs
  _listing=true
fi

source_file() {
  file="$1"
  theme="$2"
  variant="$3"
  if [ -z "$variant" ]; then
    var=
  else
    var="/$variant"
  fi
  if [ "$config_dir" == "remote" ]; then
    wget -q "$_arg_remote_url/$theme$var/$file" -O "$script_dir/.$file.tmp" &>/dev/null
    [ -f "$script_dir/.$file.tmp" ] && echo "$(cat "$script_dir/.$file.tmp")" && rm "$script_dir/.$file.tmp"
  else
    [ -f "$config_dir/$theme$var/$file" ] && echo "$(cat "$config_dir/$theme$var/$file")"
  fi
}

install_target() {
  output="$1"
  target="$2"
  theme="$3"
  variant="$4"
  source="$(source_file "$(sed "s/_/./g" <<< "$target")" "$theme" "$variant")"
  [ -z "$source" ] && return 1
  if [ "$(get_val "_cfg_${output}_${target}_replace")" == "true" ]; then
    destinations=($(get_array "_cfg_${output}_${target}_destination"))
    dest="${destinations[0]}"
    [ -f "$dest" ] && rm "$dest"
    mkdir -p "${dest%/*}"
    echo "$source" > "$dest"
  else
    destinations=($(get_array "_cfg_${output}_${target}_destination"))
    dest=$(find_dest ${destinations[*]})
    [ -z "$variant" ] && theme_str="$_arg_theme" || theme_str="$_arg_theme($_arg_variant)"
    if has_val "_cfg_${output}_${target}_comment"; then
      comments=$(get_val "_cfg_${output}_${target}_comment")
      comment_start=$(echo "$comments" | awk '{print $1}')
      comment_end=$(echo "$comments" | awk '{print $2}')
    else
      comment_start='#'
      comment_end=
    fi
    ecomment_start=$(sed 's/\//\\\//g' <<< "$comment_start")
    ecomment_start=$(sed 's/\*/\\\*/g' <<< "$comment_start")
    ecomment_end=$(sed 's/\//\\\//g' <<< "$comment_end")
    ecomment_end=$(sed 's/\*/\\\*/g' <<< "$comment_end")
    grep -Fxq "$comment_start Thema Begin -- $theme_str $comment_end" "$dest" && return 0
    if grep -xq "$ecomment_start Thema Begin -- .* $ecomment_end" "$dest"; then
      source=$(sed ':a;N;$!ba;s/\n/\\n/g' <<< "$source")
      source=$(sed 's/\//\\\//g' <<< "$source")
      sed -i "/$ecomment_start Thema Begin --/,/$ecomment_begin Thema End --/c$comment_start Thema Begin -- $theme_str $comment_end\\n$source\\n$comment_start Thema End -- $theme_str $comment_end" "$dest"
    else
      if has_val "_cfg_${output}_${target}_start_of_file" && [ "$(get_val "_cfg_${output}_${target}_start_of_file")" == "true" ]; then
        echo -e "$comment_start Thema Begin -- $theme_str $comment_end\n$source\n$comment_start Thema End -- $theme_str $comment_end\n$(cat "$dest")" > "$dest"
      else
        echo -e "$comment_start Thema Begin -- $theme_str $comment_end\n$source\n$comment_start Thema End -- $theme_str $comment_end" >> "$dest"
      fi
    fi
  fi
  return 0
}

commands=()
if [ $_listing == false ]; then
  themes=$(declare -p | grep "_cfg_themes_" | awk '{print $3}' | sed -n "s/_cfg_themes_\([^=]*\).*/\1/p")
  if [ "$(array_in "$_arg_theme" ${themes[*]})" == false ]; then
    msg_error 1 "Must specify a theme to install"
    exit 1
  fi
  variants=_cfg_themes_$_arg_theme
  if ! [ $(array_in 'default' $(array_init ${!variants})) == true ]; then
    variant_array=($(array_init ${!variants}))
    [ $(array_in "$_arg_variant" ${variant_array[*]}) == false ] && _arg_variant="${variant_array[0]}"
  fi
  [ -z "$_arg_variant" ] && theme_str="$_arg_theme" || theme_str="$_arg_theme($_arg_variant)"
  msg_header 0 "Configuring Theme $theme_str:"
  for output in ${outputs[*]}; do
    targets=($(declare -p | grep "_cfg_${output}_" | awk '{print $3}' | sed -n "s/_cfg_${output}_\([^=]*\)_destination=.*/\1/p"))
    success=true
    for target in ${targets[*]}; do
      if ! install_target "$output" "$target" "$_arg_theme" "$_arg_variant"; then
        success=false
      fi
    done
    if [ $success == true ]; then
      msg_success 1 "Configured $output to use $theme_str" || msg_error 1 "Failed to configure $output to use $theme_str"
      if has_val "_cfg_${output}_command"; then
        for i in $(seq 0 $(($(array_len "_cfg_${output}_command")-1))); do
          commands+=("$(get_val "{_cfg_${output}_command[$i]}" | sed 's/ /<SPACE>/g')")
        done
      fi
    fi
  done
fi

commands=($(array_unique ${commands[*]}))

if [ ${#commands[*]} -gt 0 ]; then
  msg_header 0 "Executing Commands:"
  for cmd in ${commands[*]}; do
    output=$($cmd)
    if [ $? -ne 0 ]; then
      msg_error 1 "$cmd"
      echo "$output"
    else
      msg_success 1 "$cmd"
    fi
  done
fi


# Cleanup
if [ $using_local == false ] && [ -f "$script_dir/.thema.yml.tmp" ]; then
  msg_header 0 "Removing temporary files"
  rm "$script_dir/.thema.yml.tmp"
fi


# ] <-- needed because of Argbash
